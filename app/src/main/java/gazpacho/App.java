/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package gazpacho;

import gazpacho.core.download.filelist.DataSourceRetriever;
import gazpacho.core.download.filelist.download.DataSourceDownloader;
import gazpacho.core.download.filelist.match.*;
import gazpacho.core.download.filelist.model.SearchResultEntry;
import gazpacho.core.download.filelist.navigate.MediaSearcher;
import gazpacho.core.download.filelist.navigate.QueryUrlResolver;
import gazpacho.core.download.filelist.navigate.SessionHandler;
import gazpacho.core.model.MediaItem;
import gazpacho.core.model.MediaType;
import gazpacho.core.util.CollectionUtils;
import gazpacho.core.util.KeyExtractor;
import gazpacho.core.util.OrderedHierarchyComparator;
import info.movito.themoviedbapi.TmdbApi;
import info.movito.themoviedbapi.TmdbSearch;
import info.movito.themoviedbapi.TmdbTrending;
import info.movito.themoviedbapi.TmdbTvSeries;
import info.movito.themoviedbapi.model.core.*;
import info.movito.themoviedbapi.model.core.multi.MultiResultsPage;
import info.movito.themoviedbapi.model.tv.series.TvSeriesDb;
import info.movito.themoviedbapi.tools.TmdbException;
import info.movito.themoviedbapi.tools.model.time.TimeWindow;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.text.similarity.LevenshteinDistance;
import org.apache.log4j.BasicConfigurator;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.nio.file.Path;
import java.util.*;

@Slf4j
public class App {
    private static final String API_READ_ACCESS_TOKEN_KEY
            = "eyJhbGciOiJIUzI1NiJ9.eyJhdWQiOiI4OWYxOTRlYTY1NzIzZTU0ZmE4MjU5YjkzMTJkZWRkOSIsIm5iZiI6MTcyNTIxNDg2NC45ODI1MzQsInN1YiI6IjY2ZDQ4ZDMwNGZhYzE0Nzc3MzU4MmNkYiIsInNjb3BlcyI6WyJhcGlfcmVhZCJdLCJ2ZXJzaW9uIjoxfQ.KX2rsy__4UzyZNHfLKR7-9rURil-mpk84LbBoc_qm3Q";
    private static final Logger LOGGER = LoggerFactory.getLogger(App.class);
    public String getGreeting() {
        return "Hello World!";
    }

    public static void main(String[] args) {
        BasicConfigurator.configure();
        testMediaSourceDownload();
    }

    private static void testMediaSourceDownload() {
        DataSourceDownloader downloader = new DataSourceDownloader(Path.of("/home/bfrancu/Downloads"), LOGGER);
        SessionHandler sessionHandler = new SessionHandler("flashback", "******", 300, 40);
        ItemQueryConverter itemQueryConverter = new ItemQueryConverter();
        QueryUrlResolver queryUrlResolver = new QueryUrlResolver(itemQueryConverter);
        MediaSearcher mediaSearcher = new MediaSearcher(queryUrlResolver, LOGGER);
        Comparator<SearchResultEntry> resultEntryComparator = new OrderedHierarchyComparator<>(
                List.of(new VideoQualityResultsComparator(),
                        new DownloadSizeResultsComparator(),
                        new SeedersCountResultsComparator())
        );

        SearchResultSelectionStrategy searchResultSelectionStrategy = new MatchingIdentifierSelectionStrategy(
                itemQueryConverter,
                resultEntryComparator,
                LOGGER
        );

        DataSourceRetriever dataSourceRetriever = new DataSourceRetriever(sessionHandler,
                mediaSearcher,
                searchResultSelectionStrategy,
                downloader,
                LOGGER);

        MediaItem mediaItem = MediaItem.builder()
                .title("The Lord of the Rings The War of the Rohirrim")
                .description("")
                .firstAirDate("2024")
                .mediaType(MediaType.MOVIE)
                .language("EN")
                .popularity(100.0)
                .build();

        Path downloadPath = dataSourceRetriever.retrieveDataSource(mediaItem);

        System.out.println("Download path: " + downloadPath);
    }

    private static void testTmdbApi() {
        TmdbApi tmdbApi = new TmdbApi(API_READ_ACCESS_TOKEN_KEY);
        printMostPopularMovie(tmdbApi, "lord of the rings", 2001);
        printMostPopularShow(tmdbApi, "breaking bad", null);
        printMostPopularShow(tmdbApi, "game of thrones", null);
        printMostPopularShow(tmdbApi, "house of the dragon", null);

    }

    private static void testStringDistance() {
        printDistance("house of usher", "the fall of the house of usher");
        printDistance("fall of house of usher", "the fall of the house of usher");
    }

    private static double similarity(String s1, String s2) {
        String longer = s1;
        String shorter = s2;
        if (longer.length() < shorter.length()) {
            longer = s2;
            shorter = s1;
        }

        if (longer.isEmpty()) {
            return 1.0;
        }

        LevenshteinDistance distance = LevenshteinDistance.getDefaultInstance();
        return truncate((longer.length() - distance.apply(longer, shorter)) / (double) longer.length());
    }

    private static void printDistance(String s1, String s2) {
        LevenshteinDistance levenshteinDistance = LevenshteinDistance.getDefaultInstance();

        int distance = levenshteinDistance.apply(s1, s2);
        LOGGER.info("Distance between {} and {} is {}", s1, s2, distance);
        LOGGER.info("Similarity between {} and {} is {}", s1, s2, similarity(s1, s2));
    }

    private static double truncate(double d) {
        return Math.floor(d * 100) / 100;
    }

    private static void printMovie(Movie movie) {
        LOGGER.info("Movie: {}, popularity: {}, release date: {}", movie.getTitle(), movie.getPopularity(), movie.getReleaseDate());
    }

    private static void printTvShow(TvSeries show) {
        LOGGER.info("Show: {}, popularity: {}, release date: {}, id: {}",
                show.getName(), show.getPopularity(), show.getFirstAirDate(), show.getId());
    }

    private static void getDetails(TmdbApi tmdbApi, TvSeries show) {
        TmdbTvSeries tmdbTvSeriesApi = tmdbApi.getTvSeries();
        try {
            TvSeriesDb tvSeriesDb = tmdbTvSeriesApi.getDetails(show.getId(), show.getOriginalLanguage());
            LOGGER.info("Show details: {}", tvSeriesDb);
        } catch (TmdbException e) {
            throw new RuntimeException(e);
        }
    }

    private static void printTrending(TmdbApi tmdbApi) {
        TmdbTrending tmdbTrending = tmdbApi.getTrending();
        try {
            MultiResultsPage allPages = tmdbTrending.getAll(TimeWindow.WEEK, null);
            allPages.forEach((page) -> {
                switch (page.getMediaType()) {
                    case MOVIE -> printMovie((Movie) page);
                    case TV_SERIES -> printTvShow((TvSeries) page);
                }
            });
        } catch (TmdbException e) {
            LOGGER.error("Tmdb exception caught", e);
        }
    }

    private static void printMostPopularMovie(TmdbApi tmdbApi, String query, Integer releaseYear) {
        getMostPopularMovie(searchMovies2(tmdbApi, query, releaseYear)).ifPresent(movie -> {
            LOGGER.info("Printing the most popular for {}", query);
            printMovie(movie);
        });
    }

    private static void printMostPopularShow(TmdbApi tmdbApi, String query, Integer releaseYear) {
        getMostPopularShow(searchShows(tmdbApi, query, releaseYear)).ifPresent(show -> {
            LOGGER.info("Printing the most popular for {}", query);
            getDetails(tmdbApi, show);
        });
    }

    private static List<TvSeries> searchShows(TmdbApi tmdbApi,
                                           String query,
                                           Integer releaseYear) {
        TmdbSearch tmdbSearch = tmdbApi.getSearch();
        TvSeriesResultsPage resultPages = null;
        try {
            resultPages = tmdbSearch.searchTv(
                    query,
                    releaseYear,
                    false,
                    null,
                    null,
                    null
            );

            resultPages.forEach(App::printTvShow);
        } catch (TmdbException e) {
            LOGGER.error("Tmdb exception caught", e);
        }
        return null != resultPages ? resultPages.getResults() : Collections.emptyList();
    }

    private static List<Movie> searchMovies(TmdbApi tmdbApi, String query, Integer releaseYear) {
        TmdbSearch tmdbSearch = tmdbApi.getSearch();
        MovieResultsPage resultPages = null;
        try {
            resultPages = tmdbSearch.searchMovie(
                    query,
                    false, null,
                    (null != releaseYear) ? String.valueOf(releaseYear) : null,
                    null, null, null
            );

            resultPages.forEach(App::printMovie);
        } catch (TmdbException e) {
            LOGGER.error("Tmdb exception caught", e);
        }
        return null != resultPages ? resultPages.getResults() : Collections.emptyList();
    }

    @FunctionalInterface
    private interface Searcher<T> {
        ResultsPage<T> search(TmdbSearch searchApi, String query, Integer releaseYear) throws TmdbException;
    }

    private static <T> List<T> search(TmdbSearch searchApi, String query, Integer releaseYear, Searcher<T> searcher) {
        List<T> results = new ArrayList<>();
        try {
            ResultsPage<T> resultPage = searcher.search(searchApi, query, releaseYear);
            results = null != resultPage ? resultPage.getResults() : Collections.emptyList();
        } catch (TmdbException e) {
            LOGGER.error("Tmdb exception caught", e);
        }
        return results;
    }

    private static List<Movie> searchMovies2(TmdbApi tmdbApi, String query, Integer releaseYear) {
        return search(tmdbApi.getSearch(), query, releaseYear, (searchApi, q, year) ->
             searchApi.searchMovie(q, false, null,
                    (null != year) ? String.valueOf(year) : null, null, null, null));
    }

    private static <T> Comparator<T> getPopularityComparator(KeyExtractor<T, Double> keyExtractor) {
       return Collections.reverseOrder(Comparator.comparingDouble(
           item -> null != keyExtractor.extract(item) ? keyExtractor.extract(item) : 0.0));
    }

    private static Optional<Movie> getMostPopularMovie(List<Movie> movies) {
        return CollectionUtils.getFirstInSortedList(movies, getPopularityComparator(movie -> movie.getPopularity()));
    }

    private static Optional<TvSeries> getMostPopularShow(List<TvSeries> tvSeries) {
        return CollectionUtils.getFirstInSortedList(tvSeries, getPopularityComparator(show -> show.getPopularity()));
    }
}
